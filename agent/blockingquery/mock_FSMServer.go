// Code generated by mockery v2.32.4. DO NOT EDIT.

/*
# Module: agent/blockingquery/mock_FSMServer.go
Mock Fsmserver module for agent layer

## Linked Modules
- [agent/consul/state](../agent/consul/state)

## Tags
agent

## Exports
MockFSMServer, NewMockFSMServer

<!-- LinkedDoc RDF -->
@prefix code: <https://schema.codedoc.org/> .
<agent/blockingquery/mock_FSMServer.go> a code:Module ;
    code:name "agent/blockingquery/mock_FSMServer.go" ;
    code:description "Mock Fsmserver module for agent layer" ;
    code:language "go" ;
    code:layer "agent" ;
    code:linksTo [
        code:name "agent/consul/state" ;
        code:path "../agent/consul/state"
    ] ;
    code:exports :MockFSMServer, :NewMockFSMServer ;
    code:tags "agent" .
<!-- End LinkedDoc RDF -->
*/
package blockingquery

import (
	time "time"

	state "github.com/hashicorp/consul/agent/consul/state"
	mock "github.com/stretchr/testify/mock"
)

// MockFSMServer is an autogenerated mock type for the FSMServer type
type MockFSMServer struct {
	mock.Mock
}

// ConsistentRead provides a mock function with given fields:
func (_m *MockFSMServer) ConsistentRead() error {
	ret := _m.Called()

	var r0 error
	if rf, ok := ret.Get(0).(func() error); ok {
		r0 = rf()
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// DecrementBlockingQueries provides a mock function with given fields:
func (_m *MockFSMServer) DecrementBlockingQueries() uint64 {
	ret := _m.Called()

	var r0 uint64
	if rf, ok := ret.Get(0).(func() uint64); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(uint64)
	}

	return r0
}

// GetShutdownChannel provides a mock function with given fields:
func (_m *MockFSMServer) GetShutdownChannel() chan struct{} {
	ret := _m.Called()

	var r0 chan struct{}
	if rf, ok := ret.Get(0).(func() chan struct{}); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(chan struct{})
		}
	}

	return r0
}

// GetState provides a mock function with given fields:
func (_m *MockFSMServer) GetState() *state.Store {
	ret := _m.Called()

	var r0 *state.Store
	if rf, ok := ret.Get(0).(func() *state.Store); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*state.Store)
		}
	}

	return r0
}

// IncrementBlockingQueries provides a mock function with given fields:
func (_m *MockFSMServer) IncrementBlockingQueries() uint64 {
	ret := _m.Called()

	var r0 uint64
	if rf, ok := ret.Get(0).(func() uint64); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(uint64)
	}

	return r0
}

// RPCQueryTimeout provides a mock function with given fields: _a0
func (_m *MockFSMServer) RPCQueryTimeout(_a0 time.Duration) time.Duration {
	ret := _m.Called(_a0)

	var r0 time.Duration
	if rf, ok := ret.Get(0).(func(time.Duration) time.Duration); ok {
		r0 = rf(_a0)
	} else {
		r0 = ret.Get(0).(time.Duration)
	}

	return r0
}

// SetQueryMeta provides a mock function with given fields: _a0, _a1
func (_m *MockFSMServer) SetQueryMeta(_a0 ResponseMeta, _a1 string) {
	_m.Called(_a0, _a1)
}

// NewMockFSMServer creates a new instance of MockFSMServer. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockFSMServer(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockFSMServer {
	mock := &MockFSMServer{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
