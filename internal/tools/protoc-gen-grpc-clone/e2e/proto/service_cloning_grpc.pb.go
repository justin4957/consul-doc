// Code generated by protoc-gen-grpc-inmem. DO NOT EDIT.

/*
# Module: internal/tools/protoc-gen-grpc-clone/e2e/proto/service_cloning_grpc.pb.go
Service Cloning Grpc.Pb module for internal layer

## Tags
api, communication, grpc, internal, networking

## Exports
CloningSimpleClient, IsCloningSimpleClient, NewCloningSimpleClient

<!-- LinkedDoc RDF -->
@prefix code: <https://schema.codedoc.org/> .
<internal/tools/protoc-gen-grpc-clone/e2e/proto/service_cloning_grpc.pb.go> a code:Module ;
    code:name "internal/tools/protoc-gen-grpc-clone/e2e/proto/service_cloning_grpc.pb.go" ;
    code:description "Service Cloning Grpc.Pb module for internal layer" ;
    code:language "go" ;
    code:layer "internal" ;
    code:exports :CloningSimpleClient, :IsCloningSimpleClient, :NewCloningSimpleClient ;
    code:tags "api", "communication", "grpc", "internal", "networking" .
<!-- End LinkedDoc RDF -->
*/
package proto

import (
	"context"

	grpc "google.golang.org/grpc"
	"google.golang.org/protobuf/proto"
)

// compile-time check to ensure that the generator is implementing all
// of the grpc client interfaces methods.
var _ SimpleClient = CloningSimpleClient{}

// IsCloningSimpleClient is an interface that can be used to detect
// that a SimpleClient is using the in-memory transport and has already
// been wrapped with a with a CloningSimpleClient.
type IsCloningSimpleClient interface {
	IsCloningSimpleClient() bool
}

// CloningSimpleClient implements the SimpleClient interface by wrapping
// another implementation and copying all protobuf messages that pass through the client.
// This is mainly useful to wrap the an in-process client to insulate users of that
// client from having to care about potential immutability of data they receive or having
// the server implementation mutate their internal memory.
type CloningSimpleClient struct {
	SimpleClient
}

func NewCloningSimpleClient(client SimpleClient) SimpleClient {
	if cloner, ok := client.(IsCloningSimpleClient); ok && cloner.IsCloningSimpleClient() {
		// prevent a double clone if the underlying client is already the cloning client.
		return client
	}

	return CloningSimpleClient{
		SimpleClient: client,
	}
}

// IsCloningSimpleClient implements the IsCloningSimpleClient interface. This
// is only used to detect wrapped clients that would be double cloning data and prevent that.
func (c CloningSimpleClient) IsCloningSimpleClient() bool {
	return true
}

func (c CloningSimpleClient) Something(ctx context.Context, in *Req, opts ...grpc.CallOption) (*Resp, error) {
	in = proto.Clone(in).(*Req)

	out, err := c.SimpleClient.Something(ctx, in)
	if err != nil {
		return nil, err
	}

	return proto.Clone(out).(*Resp), nil
}

func (c CloningSimpleClient) Flow(ctx context.Context, in *Req, opts ...grpc.CallOption) (Simple_FlowClient, error) {
	in = proto.Clone(in).(*Req)

	st, err := c.SimpleClient.Flow(ctx, in)
	if err != nil {
		return nil, err
	}

	return newCloningStream[*Resp](st), nil
}
